{
  "version": 3,
  "sources": ["../../@11labs/client/src/utils/audio.ts", "../../@11labs/client/src/utils/createWorkletModuleLoader.ts", "../../@11labs/client/src/utils/rawAudioProcessor.ts", "../../@11labs/client/src/utils/compatibility.ts", "../../@11labs/client/src/utils/input.ts", "../../@11labs/client/src/utils/audioConcatProcessor.ts", "../../@11labs/client/src/utils/output.ts", "../../@11labs/client/src/utils/events.ts", "../../@11labs/client/src/utils/connection.ts", "../../@11labs/client/src/index.ts", "../../@11labs/react/src/index.ts"],
  "sourcesContent": ["export function arrayBufferToBase64(b: ArrayBufferLike) {\n  const buffer = new Uint8Array(b);\n  // @ts-ignore\n  const base64Data = window.btoa(String.fromCharCode(...buffer));\n  return base64Data;\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n", "const URLCache = new Map<string, string>();\n\nexport function createWorkletModuleLoader(name: string, sourceCode: string) {\n  return async (worklet: AudioWorklet) => {\n    const url = URLCache.get(name);\n    if (url) {\n      return worklet.addModule(url);\n    }\n\n    const blob = new Blob([sourceCode], { type: \"application/javascript\" });\n    const blobURL = URL.createObjectURL(blob);\n    try {\n      await worklet.addModule(blobURL);\n      URLCache.set(name, blobURL);\n      return;\n    } catch {\n      URL.revokeObjectURL(blobURL);\n    }\n\n    try {\n      // Attempting to start a conversation in Safari inside an iframe will\n      // throw a CORS error because the blob:// protocol is considered\n      // cross-origin. In such cases, fall back to using a base64 data URL:\n      const base64 = btoa(sourceCode);\n      const moduleURL = `data:application/javascript;base64,${base64}`;\n      await worklet.addModule(moduleURL);\n      URLCache.set(name, moduleURL);\n    } catch (error) {\n      throw new Error(\n        `Failed to load the ${name} worklet module. Make sure the browser supports AudioWorklets.`\n      );\n    }\n  };\n}\n", "/*\n * ulaw encoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n */\n\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadRawAudioProcessor = createWorkletModuleLoader(\n  \"raw-audio-processor\",\n  // language=JavaScript\n  `\nconst BIAS = 0x84;\nconst CLIP = 32635;\nconst encodeTable = [\n  0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,\n  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7\n];\n\nfunction encodeSample(sample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let muLawSample;\n  sign = (sample >> 8) & 0x80;\n  if (sign !== 0) sample = -sample;\n  sample = sample + BIAS;\n  if (sample > CLIP) sample = CLIP;\n  exponent = encodeTable[(sample>>7) & 0xFF];\n  mantissa = (sample >> (exponent+3)) & 0x0F;\n  muLawSample = ~(sign | (exponent << 4) | mantissa);\n  \n  return muLawSample;\n}\n\nclass RawAudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n              \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.isMuted = false;\n          this.buffer = []; // Initialize an empty buffer\n          this.bufferSize = data.sampleRate / 4;\n          this.format = data.format;\n\n          if (globalThis.LibSampleRate && sampleRate !== data.sampleRate) {\n            globalThis.LibSampleRate.create(1, sampleRate, data.sampleRate).then(resampler => {\n              this.resampler = resampler;\n            });\n          }\n          break;\n        case \"setMuted\":\n          this.isMuted = data.isMuted;\n          break;\n      }\n    };\n  }\n  process(inputs) {\n    if (!this.buffer) {\n      return true;\n    }\n    \n    const input = inputs[0]; // Get the first input node\n    if (input.length > 0) {\n      let channelData = input[0]; // Get the first channel's data\n\n      // Resample the audio if necessary\n      if (this.resampler) {\n        channelData = this.resampler.full(channelData);\n      }\n\n      // Add channel data to the buffer\n      this.buffer.push(...channelData);\n      // Get max volume \n      let sum = 0.0;\n      for (let i = 0; i < channelData.length; i++) {\n        sum += channelData[i] * channelData[i];\n      }\n      const maxVolume = Math.sqrt(sum / channelData.length);\n      // Check if buffer size has reached or exceeded the threshold\n      if (this.buffer.length >= this.bufferSize) {\n        const float32Array = this.isMuted \n          ? new Float32Array(this.buffer.length)\n          : new Float32Array(this.buffer);\n\n        let encodedArray = this.format === \"ulaw\"\n          ? new Uint8Array(float32Array.length)\n          : new Int16Array(float32Array.length);\n\n        // Iterate through the Float32Array and convert each sample to PCM16\n        for (let i = 0; i < float32Array.length; i++) {\n          // Clamp the value to the range [-1, 1]\n          let sample = Math.max(-1, Math.min(1, float32Array[i]));\n\n          // Scale the sample to the range [-32768, 32767]\n          let value = sample < 0 ? sample * 32768 : sample * 32767;\n          if (this.format === \"ulaw\") {\n            value = encodeSample(Math.round(value));\n          }\n\n          encodedArray[i] = value;\n        }\n\n        // Send the buffered data to the main script\n        this.port.postMessage([encodedArray, maxVolume]);\n\n        // Clear the buffer after sending\n        this.buffer = [];\n      }\n    }\n    return true; // Continue processing\n  }\n}\nregisterProcessor(\"raw-audio-processor\", RawAudioProcessor);\n`\n);\n", "export function isIosDevice() {\n  return (\n    [\n      \"iPad Simulator\",\n      \"iPhone Simulator\",\n      \"iPod Simulator\",\n      \"iPad\",\n      \"iPhone\",\n      \"iPod\",\n    ].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document)\n  );\n}\n\nexport function isAndroidDevice() {\n  return /android/i.test(navigator.userAgent);\n}\n", "import { loadRawAudioProcessor } from \"./rawAudioProcessor\";\nimport { FormatConfig } from \"./connection\";\nimport { isIosDevice } from \"./compatibility\";\n\nexport type InputConfig = {\n  preferHeadphonesForIosDevices?: boolean;\n};\n\nconst LIBSAMPLERATE_JS =\n  \"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js\";\n\nexport class Input {\n  public static async create({\n    sampleRate,\n    format,\n    preferHeadphonesForIosDevices,\n  }: FormatConfig & InputConfig): Promise<Input> {\n    let context: AudioContext | null = null;\n    let inputStream: MediaStream | null = null;\n\n    try {\n      const options: MediaTrackConstraints = {\n        sampleRate: { ideal: sampleRate },\n        echoCancellation: { ideal: true },\n        noiseSuppression: { ideal: true },\n      };\n\n      if (isIosDevice() && preferHeadphonesForIosDevices) {\n        const availableDevices =\n          await window.navigator.mediaDevices.enumerateDevices();\n        const idealDevice = availableDevices.find(\n          d =>\n            // cautious to include \"bluetooth\" in the search\n            // as might trigger bluetooth speakers\n            d.kind === \"audioinput\" &&\n            [\"airpod\", \"headphone\", \"earphone\"].find(keyword =>\n              d.label.toLowerCase().includes(keyword)\n            )\n        );\n        if (idealDevice) {\n          options.deviceId = { ideal: idealDevice.deviceId };\n        }\n      }\n\n      const supportsSampleRateConstraint =\n        navigator.mediaDevices.getSupportedConstraints().sampleRate;\n\n      context = new window.AudioContext(\n        supportsSampleRateConstraint ? { sampleRate } : {}\n      );\n      const analyser = context.createAnalyser();\n      if (!supportsSampleRateConstraint) {\n        await context.audioWorklet.addModule(LIBSAMPLERATE_JS);\n      }\n      await loadRawAudioProcessor(context.audioWorklet);\n\n      inputStream = await navigator.mediaDevices.getUserMedia({\n        audio: options,\n      });\n\n      const source = context.createMediaStreamSource(inputStream);\n      const worklet = new AudioWorkletNode(context, \"raw-audio-processor\");\n      worklet.port.postMessage({ type: \"setFormat\", format, sampleRate });\n\n      source.connect(analyser);\n      analyser.connect(worklet);\n\n      await context.resume();\n\n      return new Input(context, analyser, worklet, inputStream);\n    } catch (error) {\n      inputStream?.getTracks().forEach(track => track.stop());\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly worklet: AudioWorkletNode,\n    public readonly inputStream: MediaStream\n  ) {}\n\n  public async close() {\n    this.inputStream.getTracks().forEach(track => track.stop());\n    await this.context.close();\n  }\n\n  public setMuted(isMuted: boolean) {\n    this.worklet.port.postMessage({ type: \"setMuted\", isMuted });\n  }\n}\n", "/*\n * ulaw decoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n */\n\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadAudioConcatProcessor = createWorkletModuleLoader(\n  \"audio-concat-processor\",\n  // language=JavaScript\n  `\nconst decodeTable = [0,132,396,924,1980,4092,8316,16764];\n\nexport function decodeSample(muLawSample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let sample;\n  muLawSample = ~muLawSample;\n  sign = (muLawSample & 0x80);\n  exponent = (muLawSample >> 4) & 0x07;\n  mantissa = muLawSample & 0x0F;\n  sample = decodeTable[exponent] + (mantissa << (exponent+3));\n  if (sign !== 0) sample = -sample;\n\n  return sample;\n}\n\nclass AudioConcatProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffers = []; // Initialize an empty buffer\n    this.cursor = 0;\n    this.currentBuffer = null;\n    this.wasInterrupted = false;\n    this.finished = false;\n    \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.format = data.format;\n          break;\n        case \"buffer\":\n          this.wasInterrupted = false;\n          this.buffers.push(\n            this.format === \"ulaw\"\n              ? new Uint8Array(data.buffer)\n              : new Int16Array(data.buffer)\n          );\n          break;\n        case \"interrupt\":\n          this.wasInterrupted = true;\n          break;\n        case \"clearInterrupted\":\n          if (this.wasInterrupted) {\n            this.wasInterrupted = false;\n            this.buffers = [];\n            this.currentBuffer = null;\n          }\n      }\n    };\n  }\n  process(_, outputs) {\n    let finished = false;\n    const output = outputs[0][0];\n    for (let i = 0; i < output.length; i++) {\n      if (!this.currentBuffer) {\n        if (this.buffers.length === 0) {\n          finished = true;\n          break;\n        }\n        this.currentBuffer = this.buffers.shift();\n        this.cursor = 0;\n      }\n\n      let value = this.currentBuffer[this.cursor];\n      if (this.format === \"ulaw\") {\n        value = decodeSample(value);\n      }\n      output[i] = value / 32768;\n      this.cursor++;\n\n      if (this.cursor >= this.currentBuffer.length) {\n        this.currentBuffer = null;\n      }\n    }\n\n    if (this.finished !== finished) {\n      this.finished = finished;\n      this.port.postMessage({ type: \"process\", finished });\n    }\n\n    return true; // Continue processing\n  }\n}\n\nregisterProcessor(\"audio-concat-processor\", AudioConcatProcessor);\n`\n);\n", "import { loadAudioConcatProcessor } from \"./audioConcatProcessor\";\nimport { FormatConfig } from \"./connection\";\n\nexport class Output {\n  public static async create({\n    sampleRate,\n    format,\n  }: FormatConfig): Promise<Output> {\n    let context: AudioContext | null = null;\n    try {\n      context = new AudioContext({ sampleRate });\n      const analyser = context.createAnalyser();\n      const gain = context.createGain();\n      gain.connect(analyser);\n      analyser.connect(context.destination);\n      await loadAudioConcatProcessor(context.audioWorklet);\n      const worklet = new AudioWorkletNode(context, \"audio-concat-processor\");\n      worklet.port.postMessage({ type: \"setFormat\", format });\n      worklet.connect(gain);\n\n      await context.resume();\n\n      return new Output(context, analyser, gain, worklet);\n    } catch (error) {\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly gain: GainNode,\n    public readonly worklet: AudioWorkletNode\n  ) {}\n\n  public async close() {\n    await this.context.close();\n  }\n}\n", "import { Language } from \"./connection\";\n\nexport type UserTranscriptionEvent = {\n  type: \"user_transcript\";\n  user_transcription_event: { user_transcript: string };\n};\nexport type AgentResponseEvent = {\n  type: \"agent_response\";\n  agent_response_event: { agent_response: string };\n};\nexport type AgentAudioEvent = {\n  type: \"audio\";\n  audio_event: {\n    audio_base_64: string;\n    event_id: number;\n  };\n};\nexport type InterruptionEvent = {\n  type: \"interruption\";\n  interruption_event: {\n    event_id: number;\n  };\n};\nexport type InternalTentativeAgentResponseEvent = {\n  type: \"internal_tentative_agent_response\";\n  tentative_agent_response_internal_event: {\n    tentative_agent_response: string;\n  };\n};\nexport type ConfigEvent = {\n  type: \"conversation_initiation_metadata\";\n  conversation_initiation_metadata_event: {\n    conversation_id: string;\n    agent_output_audio_format: string;\n    user_input_audio_format?: string;\n  };\n};\nexport type PingEvent = {\n  type: \"ping\";\n  ping_event: {\n    event_id: number;\n    ping_ms?: number;\n  };\n};\nexport type ClientToolCallEvent = {\n  type: \"client_tool_call\";\n  client_tool_call: {\n    tool_name: string;\n    tool_call_id: string;\n    parameters: any;\n    expects_response: boolean;\n  };\n};\n\n// TODO correction missing\nexport type IncomingSocketEvent =\n  | UserTranscriptionEvent\n  | AgentResponseEvent\n  | AgentAudioEvent\n  | InterruptionEvent\n  | InternalTentativeAgentResponseEvent\n  | ConfigEvent\n  | PingEvent\n  | ClientToolCallEvent;\n\nexport type PongEvent = {\n  type: \"pong\";\n  event_id: number;\n};\nexport type UserAudioEvent = {\n  user_audio_chunk: string;\n};\nexport type UserFeedbackEvent = {\n  type: \"feedback\";\n  score: \"like\" | \"dislike\";\n  event_id: number;\n};\nexport type ClientToolResultEvent = {\n  type: \"client_tool_result\";\n  tool_call_id: string;\n  result: any;\n  is_error: boolean;\n};\nexport type InitiationClientDataEvent = {\n  type: \"conversation_initiation_client_data\";\n  conversation_config_override?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      first_message?: string;\n      language?: Language;\n    };\n    tts?: {\n      voice_id?: string;\n    };\n  };\n  custom_llm_extra_body?: any;\n  dynamic_variables?: Record<string, string | number | boolean>;\n};\nexport type ContextualUpdateEvent = {\n  type: \"contextual_update\";\n  text: string;\n};\nexport type UserMessageEvent = {\n  type: \"user_message\";\n  text: string;\n};\nexport type UserActivityEvent = {\n  type: \"user_activity\";\n};\nexport type OutgoingSocketEvent =\n  | PongEvent\n  | UserAudioEvent\n  | InitiationClientDataEvent\n  | UserFeedbackEvent\n  | ClientToolResultEvent\n  | ContextualUpdateEvent\n  | UserMessageEvent\n  | UserActivityEvent;\n\nexport function isValidSocketEvent(event: any): event is IncomingSocketEvent {\n  return !!event.type;\n}\n", "import {\n  InitiationClientDataEvent,\n  ConfigEvent,\n  isValidSocketEvent,\n  OutgoingSocketEvent,\n  IncomingSocketEvent,\n} from \"./events\";\n\nconst MAIN_PROTOCOL = \"convai\";\n\nexport type Language =\n  | \"en\"\n  | \"ja\"\n  | \"zh\"\n  | \"de\"\n  | \"hi\"\n  | \"fr\"\n  | \"ko\"\n  | \"pt\"\n  | \"pt-br\"\n  | \"it\"\n  | \"es\"\n  | \"id\"\n  | \"nl\"\n  | \"tr\"\n  | \"pl\"\n  | \"sv\"\n  | \"bg\"\n  | \"ro\"\n  | \"ar\"\n  | \"cs\"\n  | \"el\"\n  | \"fi\"\n  | \"ms\"\n  | \"da\"\n  | \"ta\"\n  | \"uk\"\n  | \"ru\"\n  | \"hu\"\n  | \"hr\"\n  | \"sk\"\n  | \"no\"\n  | \"vi\";\nexport type SessionConfig = {\n  origin?: string;\n  authorization?: string;\n  overrides?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      firstMessage?: string;\n      language?: Language;\n    };\n    tts?: {\n      voiceId?: string;\n    };\n  };\n  customLlmExtraBody?: any;\n  dynamicVariables?: Record<string, string | number | boolean>;\n  useWakeLock?: boolean;\n  connectionDelay?: {\n    default: number;\n    android?: number;\n    ios?: number;\n  };\n} & (\n  | { signedUrl: string; agentId?: undefined }\n  | { agentId: string; signedUrl?: undefined }\n);\nexport type FormatConfig = {\n  format: \"pcm\" | \"ulaw\";\n  sampleRate: number;\n};\nexport type DisconnectionDetails =\n  | {\n      reason: \"error\";\n      message: string;\n      context: Event;\n    }\n  | {\n      reason: \"agent\";\n      context: CloseEvent;\n    }\n  | {\n      reason: \"user\";\n    };\nexport type OnDisconnectCallback = (details: DisconnectionDetails) => void;\nexport type OnMessageCallback = (event: IncomingSocketEvent) => void;\n\nconst WSS_API_ORIGIN = \"wss://api.elevenlabs.io\";\nconst WSS_API_PATHNAME = \"/v1/convai/conversation?agent_id=\";\n\nexport class Connection {\n  public static async create(config: SessionConfig): Promise<Connection> {\n    let socket: WebSocket | null = null;\n\n    try {\n      const origin = config.origin ?? WSS_API_ORIGIN;\n      const url = config.signedUrl\n        ? config.signedUrl\n        : origin + WSS_API_PATHNAME + config.agentId;\n\n      const protocols = [MAIN_PROTOCOL];\n      if (config.authorization) {\n        protocols.push(`bearer.${config.authorization}`);\n      }\n      socket = new WebSocket(url, protocols);\n      const conversationConfig = await new Promise<\n        ConfigEvent[\"conversation_initiation_metadata_event\"]\n      >((resolve, reject) => {\n        socket!.addEventListener(\n          \"open\",\n          () => {\n            const overridesEvent: InitiationClientDataEvent = {\n              type: \"conversation_initiation_client_data\",\n            };\n\n            if (config.overrides) {\n              overridesEvent.conversation_config_override = {\n                agent: {\n                  prompt: config.overrides.agent?.prompt,\n                  first_message: config.overrides.agent?.firstMessage,\n                  language: config.overrides.agent?.language,\n                },\n                tts: {\n                  voice_id: config.overrides.tts?.voiceId,\n                },\n              };\n            }\n\n            if (config.customLlmExtraBody) {\n              overridesEvent.custom_llm_extra_body = config.customLlmExtraBody;\n            }\n\n            if (config.dynamicVariables) {\n              overridesEvent.dynamic_variables = config.dynamicVariables;\n            }\n\n            socket?.send(JSON.stringify(overridesEvent));\n          },\n          { once: true }\n        );\n        socket!.addEventListener(\"error\", event => {\n          // In case the error event is followed by a close event, we want the\n          // latter to be the one that rejects the promise as it contains more\n          // useful information.\n          setTimeout(() => reject(event), 0);\n        });\n        socket!.addEventListener(\"close\", reject);\n        socket!.addEventListener(\n          \"message\",\n          (event: MessageEvent) => {\n            const message = JSON.parse(event.data);\n\n            if (!isValidSocketEvent(message)) {\n              return;\n            }\n\n            if (message.type === \"conversation_initiation_metadata\") {\n              resolve(message.conversation_initiation_metadata_event);\n            } else {\n              console.warn(\n                \"First received message is not conversation metadata.\"\n              );\n            }\n          },\n          { once: true }\n        );\n      });\n\n      const {\n        conversation_id,\n        agent_output_audio_format,\n        user_input_audio_format,\n      } = conversationConfig;\n\n      const inputFormat = parseFormat(user_input_audio_format ?? \"pcm_16000\");\n      const outputFormat = parseFormat(agent_output_audio_format);\n\n      return new Connection(socket, conversation_id, inputFormat, outputFormat);\n    } catch (error) {\n      socket?.close();\n      throw error;\n    }\n  }\n\n  private queue: IncomingSocketEvent[] = [];\n  private disconnectionDetails: DisconnectionDetails | null = null;\n  private onDisconnectCallback: OnDisconnectCallback | null = null;\n  private onMessageCallback: OnMessageCallback | null = null;\n\n  private constructor(\n    public readonly socket: WebSocket,\n    public readonly conversationId: string,\n    public readonly inputFormat: FormatConfig,\n    public readonly outputFormat: FormatConfig\n  ) {\n    this.socket.addEventListener(\"error\", event => {\n      // In case the error event is followed by a close event, we want the\n      // latter to be the one that disconnects the session as it contains more\n      // useful information.\n      setTimeout(\n        () =>\n          this.disconnect({\n            reason: \"error\",\n            message: \"The connection was closed due to a socket error.\",\n            context: event,\n          }),\n        0\n      );\n    });\n    this.socket.addEventListener(\"close\", event => {\n      this.disconnect(\n        event.code === 1000\n          ? {\n              reason: \"agent\",\n              context: event,\n            }\n          : {\n              reason: \"error\",\n              message:\n                event.reason || \"The connection was closed by the server.\",\n              context: event,\n            }\n      );\n    });\n    this.socket.addEventListener(\"message\", event => {\n      try {\n        const parsedEvent = JSON.parse(event.data);\n        if (!isValidSocketEvent(parsedEvent)) {\n          return;\n        }\n\n        if (this.onMessageCallback) {\n          this.onMessageCallback(parsedEvent);\n        } else {\n          this.queue.push(parsedEvent);\n        }\n      } catch (_) {}\n    });\n  }\n\n  public close() {\n    this.socket.close();\n  }\n\n  public sendMessage(message: OutgoingSocketEvent) {\n    this.socket.send(JSON.stringify(message));\n  }\n\n  public onMessage(callback: OnMessageCallback) {\n    this.onMessageCallback = callback;\n    this.queue.forEach(callback);\n    this.queue = [];\n  }\n\n  public onDisconnect(callback: OnDisconnectCallback) {\n    this.onDisconnectCallback = callback;\n    if (this.disconnectionDetails) {\n      callback(this.disconnectionDetails);\n    }\n  }\n\n  private disconnect(details: DisconnectionDetails) {\n    if (!this.disconnectionDetails) {\n      this.disconnectionDetails = details;\n      this.onDisconnectCallback?.(details);\n    }\n  }\n}\n\nfunction parseFormat(format: string): FormatConfig {\n  const [formatPart, sampleRatePart] = format.split(\"_\");\n  if (![\"pcm\", \"ulaw\"].includes(formatPart)) {\n    throw new Error(`Invalid format: ${format}`);\n  }\n\n  const sampleRate = parseInt(sampleRatePart);\n  if (isNaN(sampleRate)) {\n    throw new Error(`Invalid sample rate: ${sampleRatePart}`);\n  }\n\n  return {\n    format: formatPart as FormatConfig[\"format\"],\n    sampleRate,\n  };\n}\n", "import { arrayBufferToBase64, base64ToArrayBuffer } from \"./utils/audio\";\nimport { Input, InputConfig } from \"./utils/input\";\nimport { Output } from \"./utils/output\";\nimport {\n  Connection,\n  DisconnectionDetails,\n  OnDisconnectCallback,\n  SessionConfig,\n} from \"./utils/connection\";\nimport { ClientToolCallEvent, IncomingSocketEvent } from \"./utils/events\";\nimport { isAndroidDevice, isIosDevice } from \"./utils/compatibility\";\n\nexport type { InputConfig } from \"./utils/input\";\nexport type { IncomingSocketEvent } from \"./utils/events\";\nexport type {\n  SessionConfig,\n  DisconnectionDetails,\n  Language,\n} from \"./utils/connection\";\nexport type Role = \"user\" | \"ai\";\nexport type Mode = \"speaking\" | \"listening\";\nexport type Status =\n  | \"connecting\"\n  | \"connected\"\n  | \"disconnecting\"\n  | \"disconnected\";\nexport type Options = SessionConfig &\n  Callbacks &\n  ClientToolsConfig &\n  InputConfig;\nexport type ClientToolsConfig = {\n  clientTools: Record<\n    string,\n    (\n      parameters: any\n    ) => Promise<string | number | void> | string | number | void\n  >;\n};\nexport type Callbacks = {\n  onConnect: (props: { conversationId: string }) => void;\n  // internal debug events, not to be used\n  onDebug: (props: any) => void;\n  onDisconnect: OnDisconnectCallback;\n  onError: (message: string, context?: any) => void;\n  onMessage: (props: { message: string; source: Role }) => void;\n  onAudio: (base64Audio: string) => void;\n  onModeChange: (prop: { mode: Mode }) => void;\n  onStatusChange: (prop: { status: Status }) => void;\n  onCanSendFeedbackChange: (prop: { canSendFeedback: boolean }) => void;\n  onUnhandledClientToolCall?: (\n    params: ClientToolCallEvent[\"client_tool_call\"]\n  ) => void;\n};\n\nconst defaultClientTools = { clientTools: {} };\nconst defaultCallbacks: Callbacks = {\n  onConnect: () => {},\n  onDebug: () => {},\n  onDisconnect: () => {},\n  onError: () => {},\n  onMessage: () => {},\n  onAudio: () => {},\n  onModeChange: () => {},\n  onStatusChange: () => {},\n  onCanSendFeedbackChange: () => {},\n};\n\nconst HTTPS_API_ORIGIN = \"https://api.elevenlabs.io\";\n\nexport class Conversation {\n  public static async startSession(\n    options: SessionConfig &\n      Partial<Callbacks> &\n      Partial<ClientToolsConfig> &\n      Partial<InputConfig>\n  ): Promise<Conversation> {\n    const fullOptions: Options = {\n      ...defaultClientTools,\n      ...defaultCallbacks,\n      ...options,\n    };\n\n    fullOptions.onStatusChange({ status: \"connecting\" });\n    fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n\n    let input: Input | null = null;\n    let connection: Connection | null = null;\n    let output: Output | null = null;\n    let preliminaryInputStream: MediaStream | null = null;\n\n    let wakeLock: WakeLockSentinel | null = null;\n    if (options.useWakeLock ?? true) {\n      try {\n        wakeLock = await navigator.wakeLock.request(\"screen\");\n      } catch (e) {\n        // Wake Lock is not required for the conversation to work\n      }\n    }\n\n    try {\n      // some browsers won't allow calling getSupportedConstraints or enumerateDevices\n      // before getting approval for microphone access\n      preliminaryInputStream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n      });\n\n      const delayConfig = options.connectionDelay ?? {\n        default: 0,\n        // Give the Android AudioManager enough time to switch to the correct audio mode\n        android: 3_000,\n      };\n      let delay = delayConfig.default;\n      if (isAndroidDevice()) {\n        delay = delayConfig.android ?? delay;\n      } else if (isIosDevice()) {\n        delay = delayConfig.ios ?? delay;\n      }\n\n      if (delay > 0) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n\n      connection = await Connection.create(options);\n      [input, output] = await Promise.all([\n        Input.create({\n          ...connection.inputFormat,\n          preferHeadphonesForIosDevices: options.preferHeadphonesForIosDevices,\n        }),\n        Output.create(connection.outputFormat),\n      ]);\n\n      preliminaryInputStream?.getTracks().forEach(track => track.stop());\n      preliminaryInputStream = null;\n\n      return new Conversation(fullOptions, connection, input, output, wakeLock);\n    } catch (error) {\n      fullOptions.onStatusChange({ status: \"disconnected\" });\n      preliminaryInputStream?.getTracks().forEach(track => track.stop());\n      connection?.close();\n      await input?.close();\n      await output?.close();\n      try {\n        await wakeLock?.release();\n        wakeLock = null;\n      } catch (e) {}\n      throw error;\n    }\n  }\n\n  private lastInterruptTimestamp: number = 0;\n  private mode: Mode = \"listening\";\n  private status: Status = \"connecting\";\n  private inputFrequencyData?: Uint8Array;\n  private outputFrequencyData?: Uint8Array;\n  private volume: number = 1;\n  private currentEventId: number = 1;\n  private lastFeedbackEventId: number = 1;\n  private canSendFeedback: boolean = false;\n\n  private constructor(\n    private readonly options: Options,\n    private readonly connection: Connection,\n    public readonly input: Input,\n    public readonly output: Output,\n    public wakeLock: WakeLockSentinel | null\n  ) {\n    this.options.onConnect({ conversationId: connection.conversationId });\n\n    this.connection.onDisconnect(this.endSessionWithDetails);\n    this.connection.onMessage(this.onMessage);\n\n    this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n    this.output.worklet.port.onmessage = this.onOutputWorkletMessage;\n    this.updateStatus(\"connected\");\n  }\n\n  public endSession = () => this.endSessionWithDetails({ reason: \"user\" });\n\n  private endSessionWithDetails = async (details: DisconnectionDetails) => {\n    if (this.status !== \"connected\" && this.status !== \"connecting\") return;\n    this.updateStatus(\"disconnecting\");\n\n    try {\n      await this.wakeLock?.release();\n      this.wakeLock = null;\n    } catch (e) {}\n\n    this.connection.close();\n    await this.input.close();\n    await this.output.close();\n\n    this.updateStatus(\"disconnected\");\n    this.options.onDisconnect(details);\n  };\n\n  private updateMode = (mode: Mode) => {\n    if (mode !== this.mode) {\n      this.mode = mode;\n      this.options.onModeChange({ mode });\n    }\n  };\n\n  private updateStatus = (status: Status) => {\n    if (status !== this.status) {\n      this.status = status;\n      this.options.onStatusChange({ status });\n    }\n  };\n\n  private updateCanSendFeedback = () => {\n    const canSendFeedback = this.currentEventId !== this.lastFeedbackEventId;\n    if (this.canSendFeedback !== canSendFeedback) {\n      this.canSendFeedback = canSendFeedback;\n      this.options.onCanSendFeedbackChange({ canSendFeedback });\n    }\n  };\n\n  private onMessage = async (parsedEvent: IncomingSocketEvent) => {\n    switch (parsedEvent.type) {\n      case \"interruption\": {\n        if (parsedEvent.interruption_event) {\n          this.lastInterruptTimestamp = parsedEvent.interruption_event.event_id;\n        }\n        this.fadeOutAudio();\n        return;\n      }\n\n      case \"agent_response\": {\n        this.options.onMessage({\n          source: \"ai\",\n          message: parsedEvent.agent_response_event.agent_response,\n        });\n        return;\n      }\n\n      case \"user_transcript\": {\n        this.options.onMessage({\n          source: \"user\",\n          message: parsedEvent.user_transcription_event.user_transcript,\n        });\n        return;\n      }\n\n      case \"internal_tentative_agent_response\": {\n        this.options.onDebug({\n          type: \"tentative_agent_response\",\n          response:\n            parsedEvent.tentative_agent_response_internal_event\n              .tentative_agent_response,\n        });\n        return;\n      }\n\n      case \"client_tool_call\": {\n        if (\n          this.options.clientTools.hasOwnProperty(\n            parsedEvent.client_tool_call.tool_name\n          )\n        ) {\n          try {\n            const result =\n              (await this.options.clientTools[\n                parsedEvent.client_tool_call.tool_name\n              ](parsedEvent.client_tool_call.parameters)) ??\n              \"Client tool execution successful.\"; // default client-tool call response\n\n            // The API expects result to be a string, so we need to convert it if it's not already a string\n            const formattedResult =\n              typeof result === \"object\"\n                ? JSON.stringify(result)\n                : String(result);\n\n            this.connection.sendMessage({\n              type: \"client_tool_result\",\n              tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n              result: formattedResult,\n              is_error: false,\n            });\n          } catch (e) {\n            this.onError(\n              \"Client tool execution failed with following error: \" +\n                (e as Error)?.message,\n              {\n                clientToolName: parsedEvent.client_tool_call.tool_name,\n              }\n            );\n            this.connection.sendMessage({\n              type: \"client_tool_result\",\n              tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n              result: \"Client tool execution failed: \" + (e as Error)?.message,\n              is_error: true,\n            });\n          }\n        } else {\n          if (this.options.onUnhandledClientToolCall) {\n            this.options.onUnhandledClientToolCall(\n              parsedEvent.client_tool_call\n            );\n\n            return;\n          }\n\n          this.onError(\n            `Client tool with name ${parsedEvent.client_tool_call.tool_name} is not defined on client`,\n            {\n              clientToolName: parsedEvent.client_tool_call.tool_name,\n            }\n          );\n          this.connection.sendMessage({\n            type: \"client_tool_result\",\n            tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n            result: `Client tool with name ${parsedEvent.client_tool_call.tool_name} is not defined on client`,\n            is_error: true,\n          });\n        }\n\n        return;\n      }\n\n      case \"audio\": {\n        if (this.lastInterruptTimestamp <= parsedEvent.audio_event.event_id) {\n          this.options.onAudio(parsedEvent.audio_event.audio_base_64);\n          this.addAudioBase64Chunk(parsedEvent.audio_event.audio_base_64);\n          this.currentEventId = parsedEvent.audio_event.event_id;\n          this.updateCanSendFeedback();\n          this.updateMode(\"speaking\");\n        }\n        return;\n      }\n\n      case \"ping\": {\n        this.connection.sendMessage({\n          type: \"pong\",\n          event_id: parsedEvent.ping_event.event_id,\n        });\n        // parsedEvent.ping_event.ping_ms can be used on client side, for example\n        // to warn if ping is too high that experience might be degraded.\n        return;\n      }\n\n      // unhandled events are expected to be internal events\n      default: {\n        this.options.onDebug(parsedEvent);\n        return;\n      }\n    }\n  };\n\n  private onInputWorkletMessage = (event: MessageEvent): void => {\n    const rawAudioPcmData = event.data[0];\n    const maxVolume = event.data[1];\n\n    // check if the sound was loud enough, so we don't send unnecessary chunks\n    // then forward audio to websocket\n    //if (maxVolume > 0.001) {\n    if (this.status === \"connected\") {\n      this.connection.sendMessage({\n        user_audio_chunk: arrayBufferToBase64(rawAudioPcmData.buffer),\n        //sample_rate: this.inputAudioContext?.inputSampleRate || this.inputSampleRate,\n      });\n    }\n    //}\n  };\n\n  private onOutputWorkletMessage = ({ data }: MessageEvent): void => {\n    if (data.type === \"process\") {\n      this.updateMode(data.finished ? \"listening\" : \"speaking\");\n    }\n  };\n\n  private addAudioBase64Chunk = (chunk: string) => {\n    this.output.gain.gain.value = this.volume;\n    this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    this.output.worklet.port.postMessage({\n      type: \"buffer\",\n      buffer: base64ToArrayBuffer(chunk),\n    });\n  };\n\n  private fadeOutAudio = () => {\n    // mute agent\n    this.updateMode(\"listening\");\n    this.output.worklet.port.postMessage({ type: \"interrupt\" });\n    this.output.gain.gain.exponentialRampToValueAtTime(\n      0.0001,\n      this.output.context.currentTime + 2\n    );\n\n    // reset volume back\n    setTimeout(() => {\n      this.output.gain.gain.value = this.volume;\n      this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    }, 2000); // Adjust the duration as needed\n  };\n\n  private onError = (message: string, context?: any) => {\n    console.error(message, context);\n    this.options.onError(message, context);\n  };\n\n  private calculateVolume = (frequencyData: Uint8Array) => {\n    if (frequencyData.length === 0) {\n      return 0;\n    }\n\n    // TODO: Currently this averages all frequencies, but we should probably\n    // bias towards the frequencies that are more typical for human voice\n    let volume = 0;\n    for (let i = 0; i < frequencyData.length; i++) {\n      volume += frequencyData[i] / 255;\n    }\n    volume /= frequencyData.length;\n\n    return volume < 0 ? 0 : volume > 1 ? 1 : volume;\n  };\n\n  public getId = () => this.connection.conversationId;\n\n  public isOpen = () => this.status === \"connected\";\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    this.volume = volume;\n  };\n\n  public setMicMuted = (isMuted: boolean) => {\n    this.input.setMuted(isMuted);\n  };\n\n  public getInputByteFrequencyData = () => {\n    this.inputFrequencyData ??= new Uint8Array(\n      this.input.analyser.frequencyBinCount\n    );\n    this.input.analyser.getByteFrequencyData(this.inputFrequencyData);\n    return this.inputFrequencyData;\n  };\n\n  public getOutputByteFrequencyData = () => {\n    this.outputFrequencyData ??= new Uint8Array(\n      this.output.analyser.frequencyBinCount\n    );\n    this.output.analyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  };\n\n  public getInputVolume = () => {\n    return this.calculateVolume(this.getInputByteFrequencyData());\n  };\n\n  public getOutputVolume = () => {\n    return this.calculateVolume(this.getOutputByteFrequencyData());\n  };\n\n  public sendFeedback = (like: boolean) => {\n    if (!this.canSendFeedback) {\n      console.warn(\n        this.lastFeedbackEventId === 0\n          ? \"Cannot send feedback: the conversation has not started yet.\"\n          : \"Cannot send feedback: feedback has already been sent for the current response.\"\n      );\n      return;\n    }\n\n    this.connection.sendMessage({\n      type: \"feedback\",\n      score: like ? \"like\" : \"dislike\",\n      event_id: this.currentEventId,\n    });\n    this.lastFeedbackEventId = this.currentEventId;\n    this.updateCanSendFeedback();\n  };\n\n  public sendContextualUpdate = (text: string) => {\n    this.connection.sendMessage({\n      type: \"contextual_update\",\n      text,\n    });\n  };\n\n  public sendUserMessage = (text: string) => {\n    this.connection.sendMessage({\n      type: \"user_message\",\n      text,\n    });\n  };\n\n  public sendUserActivity = () => {\n    this.connection.sendMessage({\n      type: \"user_activity\",\n    });\n  };\n}\n\nexport function postOverallFeedback(\n  conversationId: string,\n  like: boolean,\n  origin: string = HTTPS_API_ORIGIN\n) {\n  return fetch(`${origin}/v1/convai/conversations/${conversationId}/feedback`, {\n    method: \"POST\",\n    body: JSON.stringify({\n      feedback: like ? \"like\" : \"dislike\",\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n", "import { useEffect, useRef, useState } from \"react\";\nimport {\n  Conversation,\n  Mode,\n  SessionConfig,\n  Callbacks,\n  Options,\n  Status,\n  ClientToolsConfig,\n  InputConfig,\n} from \"@11labs/client\";\n\nexport type {\n  Role,\n  Mode,\n  Status,\n  SessionConfig,\n  DisconnectionDetails,\n  Language,\n} from \"@11labs/client\";\nexport { postOverallFeedback } from \"@11labs/client\";\n\nexport type HookOptions = Partial<\n  SessionConfig & HookCallbacks & ClientToolsConfig & InputConfig\n>;\nexport type ControlledState = {\n  micMuted?: boolean;\n  volume?: number;\n};\nexport type HookCallbacks = Pick<\n  Callbacks,\n  | \"onConnect\"\n  | \"onDisconnect\"\n  | \"onError\"\n  | \"onMessage\"\n  | \"onAudio\"\n  | \"onDebug\"\n  | \"onUnhandledClientToolCall\"\n>;\n\nexport function useConversation<T extends HookOptions & ControlledState>(\n  props: T = {} as T\n) {\n  const { micMuted, volume, ...defaultOptions } = props;\n  const conversationRef = useRef<Conversation | null>(null);\n  const lockRef = useRef<Promise<Conversation> | null>(null);\n  const [status, setStatus] = useState<Status>(\"disconnected\");\n  const [canSendFeedback, setCanSendFeedback] = useState(false);\n  const [mode, setMode] = useState<Mode>(\"listening\");\n\n  useEffect(() => {\n    if (micMuted !== undefined) {\n      conversationRef?.current?.setMicMuted(micMuted);\n    }\n  }, [micMuted]);\n\n  useEffect(() => {\n    if (volume !== undefined) {\n      conversationRef?.current?.setVolume({ volume });\n    }\n  }, [volume]);\n\n  useEffect(() => {\n    return () => {\n      conversationRef.current?.endSession();\n    };\n  }, []);\n\n  return {\n    startSession: (async (options?: HookOptions) => {\n      if (conversationRef.current?.isOpen()) {\n        return conversationRef.current.getId();\n      }\n\n      if (lockRef.current) {\n        const conversation = await lockRef.current;\n        return conversation.getId();\n      }\n\n      try {\n        lockRef.current = Conversation.startSession({\n          ...(defaultOptions ?? {}),\n          ...(options ?? {}),\n          onModeChange: ({ mode }) => {\n            setMode(mode);\n          },\n          onStatusChange: ({ status }) => {\n            setStatus(status);\n          },\n          onCanSendFeedbackChange: ({ canSendFeedback }) => {\n            setCanSendFeedback(canSendFeedback);\n          },\n        } as Options);\n\n        conversationRef.current = await lockRef.current;\n        // Persist controlled state between sessions\n        if (micMuted !== undefined) {\n          conversationRef.current.setMicMuted(micMuted);\n        }\n        if (volume !== undefined) {\n          conversationRef.current.setVolume({ volume });\n        }\n\n        return conversationRef.current.getId();\n      } finally {\n        lockRef.current = null;\n      }\n    }) as T extends SessionConfig\n      ? (options?: HookOptions) => Promise<string>\n      : (options: SessionConfig & HookOptions) => Promise<string>,\n    endSession: async () => {\n      const conversation = conversationRef.current;\n      conversationRef.current = null;\n      await conversation?.endSession();\n    },\n    setVolume: ({ volume }: { volume: number }) => {\n      conversationRef.current?.setVolume({ volume });\n    },\n    getInputByteFrequencyData: () => {\n      return conversationRef.current?.getInputByteFrequencyData();\n    },\n    getOutputByteFrequencyData: () => {\n      return conversationRef.current?.getOutputByteFrequencyData();\n    },\n    getInputVolume: () => {\n      return conversationRef.current?.getInputVolume() ?? 0;\n    },\n    getOutputVolume: () => {\n      return conversationRef.current?.getOutputVolume() ?? 0;\n    },\n    sendFeedback: (like: boolean) => {\n      conversationRef.current?.sendFeedback(like);\n    },\n    getId: () => {\n      return conversationRef.current?.getId();\n    },\n    sendContextualUpdate: (text: string) => {\n      conversationRef.current?.sendContextualUpdate(text);\n    },\n    sendUserMessage: (text: string) => {\n      conversationRef.current?.sendUserMessage(text);\n    },\n    sendUserActivity: () => {\n      conversationRef.current?.sendUserActivity();\n    },\n    status,\n    canSendFeedback,\n    micMuted,\n    isSpeaking: mode === \"speaking\",\n  };\n}\n\n// const con = useConversation({agentId: \"\"})\n"],
  "mappings": "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",
  "names": ["arrayBufferToBase64", "b", "buffer", "Uint8Array", "window", "btoa", "String", "fromCharCode", "base64ToArrayBuffer", "base64", "binaryString", "atob", "len", "length", "bytes", "i", "charCodeAt", "URLCache", "Map", "createWorkletModuleLoader", "name", "sourceCode", "async", "url", "get", "worklet", "addModule", "blob", "Blob", "type", "blobURL", "URL", "createObjectURL", "set", "_unused", "revokeObjectURL", "moduleURL", "error", "Error", "loadRawAudioProcessor", "isIosDevice", "includes", "navigator", "platform", "userAgent", "document", "Input", "create", "sampleRate", "format", "preferHeadphonesForIosDevices", "context", "inputStream", "options", "ideal", "echoCancellation", "noiseSuppression", "idealDevice", "mediaDevices", "enumerateDevices", "find", "d", "kind", "keyword", "label", "toLowerCase", "deviceId", "supportsSampleRateConstraint", "getSupportedConstraints", "AudioContext", "analyser", "createAnalyser", "audioWorklet", "getUserMedia", "audio", "source", "createMediaStreamSource", "AudioWorkletNode", "port", "postMessage", "connect", "resume", "_inputStream", "_context", "getTracks", "forEach", "track", "stop", "close", "constructor", "this", "setMuted", "isMuted", "loadAudioConcatProcessor", "Output", "gain", "createGain", "destination", "isValidSocketEvent", "event", "Connection", "config", "socket", "_config$origin", "origin", "signedUrl", "agentId", "protocols", "authorization", "push", "WebSocket", "conversationConfig", "Promise", "resolve", "reject", "addEventListener", "_socket", "overridesEvent", "_config$overrides$age", "_config$overrides$age2", "_config$overrides$age3", "_config$overrides$tts", "overrides", "conversation_config_override", "agent", "prompt", "first_message", "firstMessage", "language", "tts", "voice_id", "voiceId", "customLlmExtraBody", "custom_llm_extra_body", "dynamicVariables", "dynamic_variables", "send", "JSON", "stringify", "once", "setTimeout", "message", "parse", "data", "conversation_initiation_metadata_event", "console", "warn", "conversation_id", "agent_output_audio_format", "user_input_audio_format", "inputFormat", "parseFormat", "outputFormat", "_socket2", "conversationId", "queue", "disconnectionDetails", "onDisconnectCallback", "onMessageCallback", "disconnect", "reason", "code", "parsedEvent", "_", "sendMessage", "onMessage", "callback", "onDisconnect", "details", "_this$onDisconnectCal", "call", "formatPart", "sampleRatePart", "split", "parseInt", "isNaN", "defaultClientTools", "clientTools", "defaultCallbacks", "onConnect", "onDebug", "onError", "onAudio", "onModeChange", "onStatusChange", "onCanSendFeedbackChange", "Conversation", "_options$useWakeLock", "fullOptions", "_extends", "status", "canSendFeedback", "input", "connection", "output", "preliminaryInputStream", "wakeLock", "useWakeLock", "request", "e", "_options$connectionDe", "_preliminaryInputStre", "delayConfig", "connectionDelay", "default", "android", "delay", "_delayConfig$android", "test", "_delayConfig$ios", "ios", "all", "_preliminaryInputStre2", "_connection", "_input", "_output", "_wakeLock", "release", "_this", "lastInterruptTimestamp", "mode", "inputFrequencyData", "outputFrequencyData", "volume", "currentEventId", "lastFeedbackEventId", "endSession", "endSessionWithDetails", "updateStatus", "_this$wakeLock", "updateMode", "updateCanSendFeedback", "interruption_event", "event_id", "fadeOutAudio", "agent_response_event", "agent_response", "user_transcription_event", "user_transcript", "response", "tentative_agent_response_internal_event", "tentative_agent_response", "hasOwnProperty", "client_tool_call", "tool_name", "_await$_this$options$", "result", "parameters", "formattedResult", "tool_call_id", "is_error", "clientToolName", "onUnhandledClientToolCall", "audio_event", "audio_base_64", "addAudioBase64Chunk", "ping_event", "onInputWorkletMessage", "user_audio_chunk", "onOutputWorkletMessage", "finished", "chunk", "value", "exponentialRampToValueAtTime", "currentTime", "calculateVolume", "frequencyData", "getId", "isOpen", "setVolume", "setMicMuted", "getInputByteFrequencyData", "frequencyBinCount", "getByteFrequencyData", "getOutputByteFrequencyData", "getInputVolume", "getOutputVolume", "sendFeedback", "like", "score", "sendContextualUpdate", "text", "sendUserMessage", "sendUserActivity", "onmessage", "postOverallFeedback", "fetch", "method", "body", "feedback", "headers", "_excluded", "useConversation", "props", "micMuted", "volume", "defaultOptions", "conversationRef", "useRef", "lockRef", "status", "setStatus", "useState", "canSendFeedback", "setCanSendFeedback", "mode", "setMode", "useEffect", "_conversationRef$curr", "current", "setMicMuted", "_conversationRef$curr2", "setVolume", "_conversationRef$curr3", "endSession", "startSession", "async", "_conversationRef$curr4", "isOpen", "getId", "Conversation", "_extends", "options", "onModeChange", "onStatusChange", "onCanSendFeedbackChange", "conversation", "_conversationRef$curr5", "getInputByteFrequencyData", "_conversationRef$curr6", "getOutputByteFrequencyData", "_conversationRef$curr7", "getInputVolume", "_conversationRef$curr8", "_conversationRef$curr9", "getOutputVolume", "_conversationRef$curr10", "_conversationRef$curr11", "sendFeedback", "like", "_conversationRef$curr12", "_conversationRef$curr13", "sendContextualUpdate", "text", "_conversationRef$curr14", "sendUserMessage", "_conversationRef$curr15", "sendUserActivity", "_conversationRef$curr16", "isSpeaking"]
}
